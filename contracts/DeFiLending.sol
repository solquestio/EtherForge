// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

/**
 * @title DeFiLending
 * @dev Production-ready DeFi lending protocol generated by VibeForge
 * @dev Integrates Chainlink price feeds and OpenZeppelin security for ETH Dublin 2025
 */
contract DeFiLending is ReentrancyGuard, Ownable, Pausable {
    using SafeERC20 for IERC20;

    // Chainlink Price Feed Interface
    AggregatorV3Interface internal ethUsdPriceFeed;
    AggregatorV3Interface internal btcUsdPriceFeed;
    
    // State Variables
    uint256 public constant LIQUIDATION_THRESHOLD = 75; // 75% LTV
    uint256 public constant LIQUIDATION_PENALTY = 10; // 10% penalty
    uint256 public constant INTEREST_RATE = 500; // 5% APY (in basis points)
    uint256 public constant MIN_COLLATERAL_USD = 100 * 1e8; // $100 minimum collateral
    
    // Supported tokens
    mapping(address => bool) public supportedTokens;
    mapping(address => AggregatorV3Interface) public tokenPriceFeeds;
    mapping(address => uint256) public tokenCollateralFactors; // In basis points (7500 = 75%)
    
    // User data
    struct UserAccount {
        uint256 collateralETH;
        uint256 collateralBTC;
        uint256 borrowedUSD;
        uint256 lastInterestUpdate;
        bool isActive;
    }
    
    mapping(address => UserAccount) public userAccounts;
    
    // Protocol state
    uint256 public totalLiquidity;
    uint256 public totalBorrowed;
    uint256 public protocolReserves;
    
    // Events
    event CollateralDeposited(address indexed user, address indexed token, uint256 amount, uint256 usdValue);
    event CollateralWithdrawn(address indexed user, address indexed token, uint256 amount);
    event LoanBorrowed(address indexed user, uint256 amount, uint256 interestRate);
    event LoanRepaid(address indexed user, uint256 amount, uint256 interest);
    event Liquidation(address indexed user, address indexed liquidator, uint256 debtAmount, uint256 collateralSeized);
    event PriceFeedUpdated(address indexed token, address indexed priceFeed);
    event InterestRateUpdated(uint256 newRate);

    /**
     * @dev Contract constructor
     * @param _ethUsdPriceFeed Chainlink ETH/USD price feed address
     * @param _btcUsdPriceFeed Chainlink BTC/USD price feed address
     */
    constructor(
        address _ethUsdPriceFeed,
        address _btcUsdPriceFeed
    ) Ownable(msg.sender) {
        ethUsdPriceFeed = AggregatorV3Interface(_ethUsdPriceFeed);
        btcUsdPriceFeed = AggregatorV3Interface(_btcUsdPriceFeed);
        
        // Set default collateral factors (75% for ETH, 70% for BTC)
        tokenCollateralFactors[address(0)] = 7500; // ETH
        tokenCollateralFactors[address(1)] = 7000; // BTC placeholder
    }

    /**
     * @dev Get the latest ETH price from Chainlink
     * @return Latest ETH price in USD (8 decimals)
     */
    function getLatestETHPrice() public view returns (int256) {
        (, int256 price, , uint256 timeStamp, ) = ethUsdPriceFeed.latestRoundData();
        require(timeStamp > 0, "Round not complete");
        require(price > 0, "Invalid price");
        return price;
    }

    /**
     * @dev Get the latest BTC price from Chainlink
     * @return Latest BTC price in USD (8 decimals)
     */
    function getLatestBTCPrice() public view returns (int256) {
        (, int256 price, , uint256 timeStamp, ) = btcUsdPriceFeed.latestRoundData();
        require(timeStamp > 0, "Round not complete");
        require(price > 0, "Invalid price");
        return price;
    }

    /**
     * @dev Calculate USD value of ETH amount
     * @param _ethAmount Amount of ETH (in wei)
     * @return USD value (8 decimals)
     */
    function getETHValueInUSD(uint256 _ethAmount) public view returns (uint256) {
        int256 ethPrice = getLatestETHPrice();
        return (_ethAmount * uint256(ethPrice)) / 1e18;
    }

    /**
     * @dev Calculate USD value of user's total collateral
     * @param _user User address
     * @return Total collateral value in USD (8 decimals)
     */
    function getUserCollateralValueUSD(address _user) public view returns (uint256) {
        UserAccount memory account = userAccounts[_user];
        uint256 totalValueUSD = 0;
        
        // ETH collateral value
        if (account.collateralETH > 0) {
            totalValueUSD += getETHValueInUSD(account.collateralETH);
        }
        
        // BTC collateral value (simplified - assuming BTC is tracked in 8 decimals)
        if (account.collateralBTC > 0) {
            int256 btcPrice = getLatestBTCPrice();
            totalValueUSD += (account.collateralBTC * uint256(btcPrice)) / 1e8;
        }
        
        return totalValueUSD;
    }

    /**
     * @dev Calculate maximum borrowable amount for user
     * @param _user User address
     * @return Maximum borrowable amount in USD (8 decimals)
     */
    function getMaxBorrowableAmount(address _user) public view returns (uint256) {
        uint256 collateralValueUSD = getUserCollateralValueUSD(_user);
        return (collateralValueUSD * LIQUIDATION_THRESHOLD) / 100;
    }

    /**
     * @dev Calculate current health factor for user
     * @param _user User address
     * @return Health factor (1e18 = 100%)
     */
    function getHealthFactor(address _user) public view returns (uint256) {
        UserAccount memory account = userAccounts[_user];
        
        if (account.borrowedUSD == 0) {
            return type(uint256).max; // No debt = infinite health
        }
        
        uint256 collateralValueUSD = getUserCollateralValueUSD(_user);
        uint256 maxBorrowable = (collateralValueUSD * LIQUIDATION_THRESHOLD) / 100;
        
        return (maxBorrowable * 1e18) / account.borrowedUSD;
    }

    /**
     * @dev Deposit ETH as collateral
     */
    function depositETHCollateral() 
        external 
        payable 
        nonReentrant 
        whenNotPaused 
    {
        require(msg.value > 0, "Must deposit some ETH");
        
        uint256 usdValue = getETHValueInUSD(msg.value);
        require(usdValue >= MIN_COLLATERAL_USD, "Collateral below minimum");
        
        UserAccount storage account = userAccounts[msg.sender];
        account.collateralETH += msg.value;
        account.isActive = true;
        
        emit CollateralDeposited(msg.sender, address(0), msg.value, usdValue);
    }

    /**
     * @dev Withdraw ETH collateral
     * @param _amount Amount of ETH to withdraw (in wei)
     */
    function withdrawETHCollateral(uint256 _amount) 
        external 
        nonReentrant 
        whenNotPaused 
    {
        UserAccount storage account = userAccounts[msg.sender];
        require(account.collateralETH >= _amount, "Insufficient collateral");
        
        // Check if withdrawal would make position unhealthy
        account.collateralETH -= _amount;
        
        if (account.borrowedUSD > 0) {
            uint256 newHealthFactor = getHealthFactor(msg.sender);
            require(newHealthFactor >= 1e18, "Would liquidate position");
        }
        
        payable(msg.sender).transfer(_amount);
        
        emit CollateralWithdrawn(msg.sender, address(0), _amount);
    }

    /**
     * @dev Borrow USD against collateral
     * @param _amount Amount to borrow in USD (8 decimals)
     */
    function borrow(uint256 _amount) 
        external 
        nonReentrant 
        whenNotPaused 
    {
        require(_amount > 0, "Cannot borrow 0");
        require(totalLiquidity >= _amount, "Insufficient liquidity");
        
        UserAccount storage account = userAccounts[msg.sender];
        require(account.isActive, "No collateral deposited");
        
        // Update interest before borrowing
        _updateUserInterest(msg.sender);
        
        uint256 maxBorrowable = getMaxBorrowableAmount(msg.sender);
        require(account.borrowedUSD + _amount <= maxBorrowable, "Exceeds borrowing capacity");
        
        account.borrowedUSD += _amount;
        account.lastInterestUpdate = block.timestamp;
        
        totalBorrowed += _amount;
        totalLiquidity -= _amount;
        
        // Transfer borrowed amount (simplified - assuming USD stablecoin)
        // In production, this would transfer actual stablecoins
        
        emit LoanBorrowed(msg.sender, _amount, INTEREST_RATE);
    }

    /**
     * @dev Repay borrowed amount
     * @param _amount Amount to repay in USD (8 decimals)
     */
    function repay(uint256 _amount) 
        external 
        payable 
        nonReentrant 
        whenNotPaused 
    {
        UserAccount storage account = userAccounts[msg.sender];
        require(account.borrowedUSD > 0, "No debt to repay");
        
        // Update interest before repayment
        _updateUserInterest(msg.sender);
        
        uint256 totalOwed = account.borrowedUSD;
        uint256 repayAmount = _amount > totalOwed ? totalOwed : _amount;
        
        account.borrowedUSD -= repayAmount;
        
        totalBorrowed -= repayAmount;
        totalLiquidity += repayAmount;
        
        emit LoanRepaid(msg.sender, repayAmount, 0);
    }

    /**
     * @dev Liquidate undercollateralized position
     * @param _user User to liquidate
     * @param _debtToCover Amount of debt to cover
     */
    function liquidate(address _user, uint256 _debtToCover) 
        external 
        payable 
        nonReentrant 
        whenNotPaused 
    {
        require(_user != msg.sender, "Cannot liquidate yourself");
        
        uint256 healthFactor = getHealthFactor(_user);
        require(healthFactor < 1e18, "Position is healthy");
        
        UserAccount storage account = userAccounts[_user];
        require(_debtToCover <= account.borrowedUSD, "Cannot cover more than debt");
        
        // Calculate collateral to seize (with liquidation penalty)
        uint256 collateralValueUSD = getUserCollateralValueUSD(_user);
        uint256 collateralToSeizeUSD = (_debtToCover * (100 + LIQUIDATION_PENALTY)) / 100;
        
        require(collateralToSeizeUSD <= collateralValueUSD, "Not enough collateral");
        
        // Calculate ETH amount to seize
        uint256 ethToSeize = (collateralToSeizeUSD * 1e18) / uint256(getLatestETHPrice());
        require(ethToSeize <= account.collateralETH, "Insufficient ETH collateral");
        
        // Update balances
        account.borrowedUSD -= _debtToCover;
        account.collateralETH -= ethToSeize;
        
        totalBorrowed -= _debtToCover;
        totalLiquidity += _debtToCover;
        
        // Transfer seized collateral to liquidator
        payable(msg.sender).transfer(ethToSeize);
        
        emit Liquidation(_user, msg.sender, _debtToCover, ethToSeize);
    }

    /**
     * @dev Add liquidity to the protocol
     */
    function addLiquidity() 
        external 
        payable 
        onlyOwner 
    {
        totalLiquidity += msg.value;
    }

    /**
     * @dev Update interest for a user
     * @param _user User address
     */
    function _updateUserInterest(address _user) internal {
        UserAccount storage account = userAccounts[_user];
        
        if (account.borrowedUSD > 0 && account.lastInterestUpdate > 0) {
            uint256 timeElapsed = block.timestamp - account.lastInterestUpdate;
            uint256 interest = (account.borrowedUSD * INTEREST_RATE * timeElapsed) / (365 days * 10000);
            
            account.borrowedUSD += interest;
            protocolReserves += interest / 10; // 10% to protocol reserves
        }
        
        account.lastInterestUpdate = block.timestamp;
    }

    /**
     * @dev Update Chainlink price feed addresses
     * @param _token Token address (0 for ETH, 1 for BTC)
     * @param _priceFeed New price feed address
     */
    function updatePriceFeed(address _token, address _priceFeed) 
        external 
        onlyOwner 
    {
        require(_priceFeed != address(0), "Invalid price feed");
        
        if (_token == address(0)) {
            ethUsdPriceFeed = AggregatorV3Interface(_priceFeed);
        } else if (_token == address(1)) {
            btcUsdPriceFeed = AggregatorV3Interface(_priceFeed);
        }
        
        emit PriceFeedUpdated(_token, _priceFeed);
    }

    /**
     * @dev Emergency pause
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @dev Unpause
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @dev Get user account information
     * @param _user User address
     * @return UserAccount struct
     */
    function getUserAccount(address _user) 
        external 
        view 
        returns (UserAccount memory) 
    {
        return userAccounts[_user];
    }

    /**
     * @dev Get protocol statistics
     * @return totalLiquidity, totalBorrowed, utilizationRate
     */
    function getProtocolStats() 
        external 
        view 
        returns (uint256, uint256, uint256) 
    {
        uint256 utilizationRate = totalLiquidity > 0 ? 
            (totalBorrowed * 10000) / (totalLiquidity + totalBorrowed) : 0;
        
        return (totalLiquidity, totalBorrowed, utilizationRate);
    }

    /**
     * @dev Withdraw protocol reserves
     * @param _amount Amount to withdraw
     */
    function withdrawReserves(uint256 _amount) 
        external 
        onlyOwner 
        nonReentrant 
    {
        require(_amount <= protocolReserves, "Insufficient reserves");
        
        protocolReserves -= _amount;
        payable(owner()).transfer(_amount);
    }

    /**
     * @dev Receive function to accept ETH deposits
     */
    receive() external payable {
        totalLiquidity += msg.value;
    }
} 