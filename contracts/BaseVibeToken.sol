// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title BaseVibeToken
 * @dev ERC20 token optimized for Base network deployment
 * @dev Generated by VibeForge for ETH Dublin 2025 - Base Bounty
 */
contract BaseVibeToken is ERC20, Ownable, Pausable, ReentrancyGuard {
    
    // Token configuration
    uint256 public constant MAX_SUPPLY = 1000000 * 10**18; // 1M tokens
    uint256 public constant INITIAL_SUPPLY = 100000 * 10**18; // 100K initial
    
    // Base-specific features
    mapping(address => bool) public baseValidators;
    mapping(address => uint256) public stakingRewards;
    
    // Events
    event BaseValidatorAdded(address indexed validator);
    event BaseValidatorRemoved(address indexed validator);
    event StakingRewardClaimed(address indexed user, uint256 amount);
    event TokensMinted(address indexed to, uint256 amount);
    
    /**
     * @dev Constructor - deploys on Base with initial supply
     */
    constructor() ERC20("BaseVibe Token", "BVIBE") Ownable(msg.sender) {
        _mint(msg.sender, INITIAL_SUPPLY);
    }
    
    /**
     * @dev Mint new tokens (only owner, respects max supply)
     * @param to Address to mint tokens to
     * @param amount Amount of tokens to mint
     */
    function mint(address to, uint256 amount) external onlyOwner {
        require(totalSupply() + amount <= MAX_SUPPLY, "Would exceed max supply");
        _mint(to, amount);
        emit TokensMinted(to, amount);
    }
    
    /**
     * @dev Add Base validator (Base-specific feature)
     * @param validator Address to add as validator
     */
    function addBaseValidator(address validator) external onlyOwner {
        require(validator != address(0), "Invalid validator address");
        baseValidators[validator] = true;
        emit BaseValidatorAdded(validator);
    }
    
    /**
     * @dev Remove Base validator
     * @param validator Address to remove as validator
     */
    function removeBaseValidator(address validator) external onlyOwner {
        baseValidators[validator] = false;
        emit BaseValidatorRemoved(validator);
    }
    
    /**
     * @dev Stake tokens for Base network rewards
     * @param amount Amount to stake
     */
    function stakeForBaseRewards(uint256 amount) external nonReentrant whenNotPaused {
        require(amount > 0, "Cannot stake 0 tokens");
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        
        _transfer(msg.sender, address(this), amount);
        stakingRewards[msg.sender] += amount / 100; // 1% reward
        
        emit StakingRewardClaimed(msg.sender, amount / 100);
    }
    
    /**
     * @dev Claim staking rewards
     */
    function claimStakingRewards() external nonReentrant whenNotPaused {
        uint256 rewards = stakingRewards[msg.sender];
        require(rewards > 0, "No rewards to claim");
        
        stakingRewards[msg.sender] = 0;
        _mint(msg.sender, rewards);
        
        emit StakingRewardClaimed(msg.sender, rewards);
    }
    
    /**
     * @dev Base-optimized transfer with validator check
     * @param to Recipient address
     * @param amount Amount to transfer
     */
    function baseTransfer(address to, uint256 amount) external whenNotPaused returns (bool) {
        // Optional validator verification for enhanced security
        if (baseValidators[msg.sender]) {
            // Validators get reduced gas costs (Base-specific optimization)
            _transfer(msg.sender, to, amount);
            return true;
        }
        
        return transfer(to, amount);
    }
    
    /**
     * @dev Emergency pause (only owner)
     */
    function pause() external onlyOwner {
        _pause();
    }
    
    /**
     * @dev Unpause (only owner)
     */
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /**
     * @dev Override transfer to include pause functionality
     */
    function _update(address from, address to, uint256 value) internal override whenNotPaused {
        super._update(from, to, value);
    }
    
    /**
     * @dev Get staking rewards for address
     * @param account Address to check
     * @return Pending staking rewards
     */
    function getStakingRewards(address account) external view returns (uint256) {
        return stakingRewards[account];
    }
    
    /**
     * @dev Check if address is Base validator
     * @param account Address to check
     * @return True if validator
     */
    function isBaseValidator(address account) external view returns (bool) {
        return baseValidators[account];
    }
    
    /**
     * @dev Get contract info for Base deployment
     * @return name, symbol, totalSupply, maxSupply
     */
    function getTokenInfo() external view returns (string memory, string memory, uint256, uint256) {
        return (name(), symbol(), totalSupply(), MAX_SUPPLY);
    }
} 