// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title VibeForgeNFT
 * @dev Production-ready NFT contract generated by VibeForge
 * @dev Showcases OpenZeppelin security best practices for ETH Dublin 2025
 */
contract VibeForgeNFT is 
    ERC721, 
    ERC721Enumerable, 
    ERC721URIStorage, 
    ReentrancyGuard, 
    Ownable, 
    Pausable 
{
    // State Variables
    uint256 private _tokenIdCounter;
    
    uint256 public constant MAX_SUPPLY = 10000;
    uint256 public mintPrice = 0.05 ether;
    uint256 public maxMintPerTransaction = 10;
    uint256 public maxMintPerWallet = 50;
    
    bool public publicMintEnabled = false;
    string private _baseTokenURI;
    
    // Royalty Info (EIP-2981)
    address public royaltyReceiver;
    uint256 public royaltyPercentage = 750; // 7.5%
    
    // Mapping for minted count per wallet
    mapping(address => uint256) public walletMintCount;
    
    // Events
    event MintPriceUpdated(uint256 newPrice);
    event MaxMintPerTransactionUpdated(uint256 newMax);
    event PublicMintToggled(bool enabled);
    event RoyaltyInfoUpdated(address receiver, uint256 percentage);
    event TokenMinted(address indexed to, uint256 indexed tokenId, string tokenURI);

    /**
     * @dev Contract constructor
     * @param _name Token name
     * @param _symbol Token symbol  
     * @param _initialBaseURI Initial base URI for metadata
     */
    constructor(
        string memory _name,
        string memory _symbol,
        string memory _initialBaseURI
    ) ERC721(_name, _symbol) Ownable(msg.sender) {
        _baseTokenURI = _initialBaseURI;
        royaltyReceiver = msg.sender;
        
        // Start token IDs at 1
        _tokenIdCounter = 1;
    }

    /**
     * @dev Public mint function with OpenZeppelin security guards
     * @param _quantity Number of tokens to mint
     */
    function publicMint(uint256 _quantity) 
        external 
        payable 
        nonReentrant 
        whenNotPaused 
    {
        require(publicMintEnabled, "Public mint not enabled");
        require(_quantity > 0, "Quantity must be greater than 0");
        require(_quantity <= maxMintPerTransaction, "Exceeds max mint per transaction");
        require(
            walletMintCount[msg.sender] + _quantity <= maxMintPerWallet, 
            "Exceeds max mint per wallet"
        );
        require(
            totalSupply() + _quantity <= MAX_SUPPLY, 
            "Would exceed max supply"
        );
        require(msg.value >= mintPrice * _quantity, "Insufficient payment");

        // Update wallet mint count
        walletMintCount[msg.sender] += _quantity;

        // Mint tokens
        for (uint256 i = 0; i < _quantity; i++) {
            uint256 tokenId = _tokenIdCounter;
            _tokenIdCounter++;
            
            _safeMint(msg.sender, tokenId);
            
            emit TokenMinted(msg.sender, tokenId, tokenURI(tokenId));
        }

        // Refund excess payment
        if (msg.value > mintPrice * _quantity) {
            payable(msg.sender).transfer(msg.value - (mintPrice * _quantity));
        }
    }

    /**
     * @dev Owner mint function for airdrops and team allocation
     * @param _to Recipient address
     * @param _quantity Number of tokens to mint
     */
    function ownerMint(address _to, uint256 _quantity) 
        external 
        onlyOwner 
        nonReentrant 
    {
        require(_to != address(0), "Cannot mint to zero address");
        require(_quantity > 0, "Quantity must be greater than 0");
        require(
            totalSupply() + _quantity <= MAX_SUPPLY, 
            "Would exceed max supply"
        );

        for (uint256 i = 0; i < _quantity; i++) {
            uint256 tokenId = _tokenIdCounter;
            _tokenIdCounter++;
            
            _safeMint(_to, tokenId);
            
            emit TokenMinted(_to, tokenId, tokenURI(tokenId));
        }
    }

    /**
     * @dev Set individual token URI (for unique metadata)
     * @param _tokenId Token ID
     * @param _tokenURI Token URI
     */
    function setTokenURI(uint256 _tokenId, string memory _tokenURI) 
        external 
        onlyOwner 
    {
        require(_ownerOf(_tokenId) != address(0), "Token does not exist");
        _setTokenURI(_tokenId, _tokenURI);
    }

    // Admin Functions

    /**
     * @dev Update mint price
     * @param _newPrice New mint price in wei
     */
    function setMintPrice(uint256 _newPrice) external onlyOwner {
        mintPrice = _newPrice;
        emit MintPriceUpdated(_newPrice);
    }

    /**
     * @dev Update max mint per transaction
     * @param _newMax New maximum mint per transaction
     */
    function setMaxMintPerTransaction(uint256 _newMax) external onlyOwner {
        require(_newMax > 0, "Max must be greater than 0");
        maxMintPerTransaction = _newMax;
        emit MaxMintPerTransactionUpdated(_newMax);
    }

    /**
     * @dev Update max mint per wallet
     * @param _newMax New maximum mint per wallet
     */
    function setMaxMintPerWallet(uint256 _newMax) external onlyOwner {
        require(_newMax > 0, "Max must be greater than 0");
        maxMintPerWallet = _newMax;
    }

    /**
     * @dev Toggle public mint
     * @param _enabled Whether public mint is enabled
     */
    function setPublicMintEnabled(bool _enabled) external onlyOwner {
        publicMintEnabled = _enabled;
        emit PublicMintToggled(_enabled);
    }

    /**
     * @dev Set base URI for metadata
     * @param _newBaseURI New base URI
     */
    function setBaseURI(string memory _newBaseURI) external onlyOwner {
        _baseTokenURI = _newBaseURI;
    }

    /**
     * @dev Set royalty information
     * @param _receiver Royalty receiver address
     * @param _percentage Royalty percentage (in basis points, e.g., 750 = 7.5%)
     */
    function setRoyaltyInfo(address _receiver, uint256 _percentage) 
        external 
        onlyOwner 
    {
        require(_receiver != address(0), "Cannot set zero address as receiver");
        require(_percentage <= 1000, "Royalty percentage cannot exceed 10%");
        
        royaltyReceiver = _receiver;
        royaltyPercentage = _percentage;
        
        emit RoyaltyInfoUpdated(_receiver, _percentage);
    }

    /**
     * @dev Pause contract (emergency stop)
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @dev Unpause contract
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @dev Withdraw contract balance
     */
    function withdraw() external onlyOwner nonReentrant {
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");
        
        (bool success, ) = payable(owner()).call{value: balance}("");
        require(success, "Withdrawal failed");
    }

    // View Functions

    /**
     * @dev Get total number of tokens minted
     */
    function totalMinted() external view returns (uint256) {
        return _tokenIdCounter - 1;
    }

    /**
     * @dev Get tokens owned by address
     * @param _owner Owner address
     */
    function tokensOfOwner(address _owner) 
        external 
        view 
        returns (uint256[] memory) 
    {
        uint256 tokenCount = balanceOf(_owner);
        uint256[] memory tokens = new uint256[](tokenCount);
        
        for (uint256 i = 0; i < tokenCount; i++) {
            tokens[i] = tokenOfOwnerByIndex(_owner, i);
        }
        
        return tokens;
    }

    /**
     * @dev Check if contract supports interface (EIP-165)
     */
    function supportsInterface(bytes4 interfaceId) 
        public 
        view 
        override(ERC721, ERC721Enumerable, ERC721URIStorage) 
        returns (bool) 
    {
        return super.supportsInterface(interfaceId);
    }

    /**
     * @dev Get royalty information (EIP-2981)
     */
    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) 
        external 
        view 
        returns (address, uint256) 
    {
        return (royaltyReceiver, (_salePrice * royaltyPercentage) / 10000);
    }

    // Internal Functions

    /**
     * @dev Base URI for metadata
     */
    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev Hook called before token transfer
     */
    function _update(
        address to,
        uint256 tokenId,
        address auth
    ) internal override(ERC721, ERC721Enumerable) whenNotPaused returns (address) {
        return super._update(to, tokenId, auth);
    }

    /**
     * @dev Increase balance
     */
    function _increaseBalance(address account, uint128 value) internal override(ERC721, ERC721Enumerable) {
        super._increaseBalance(account, value);
    }

    /**
     * @dev Token URI function override
     */
    function tokenURI(uint256 tokenId) 
        public 
        view 
        override(ERC721, ERC721URIStorage) 
        returns (string memory) 
    {
        return super.tokenURI(tokenId);
    }
} 